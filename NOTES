Definitions
	'form' - a syntactic part of a program
	"subr" - a built-in function
	"special form" - a function that is handled specially by eval,
			 often because its args should not be evaluated.
	"macro" - a function called from read, not from eval.
	"lexpr" - ???
	"environment - ???
    	"dynamic extent" the time a function activation is alive.

Data
	object
	  abstract superclass
	    eq?()
	boolean
	integer
	    new()
	    number?()
	    c_int()
	character
	pair (cons)
	    new()
	    consp()
	    car()
	    cdr()
	    setcar()
	    setcdr()
	symbol (atom)
	    new()
	    symbol-bound?()
	    symbol-value(sym, value, env=None)
	    set-symbol_value(sym. value, value, env=None)
	activation frame
	exception
	built-in atoms
	   #t #f lambda
	transformer
    	dynamic environment
	    continuation
	    exception handler
    	    variable bindings
    	    other?
	later...
	    string
	    vector
	    other numeric types

Program
	read-eval-print
	read
	  read-token
	string->symbol (aka intern)
	eval
	  eval-variable
	  eval-list
	print
	bind (global)
	math primitives
	string primitives

Special forms
	define
	lambda
	let

Resources

    http://srfi.schemers.org/
    http://srfi.schemers.org/srfi-18/

Layers

    storage
    storage: blocks of data, format objects.

----------------------------------

Notes

Recognizing special forms.

    It seems like there are three kinds of functions.
    Regular functions, syntaxes (syntaces?), and, um,
    special forms.

    SIOD has these.

	#define tc_subr_0 4
	#define tc_subr_1 5
	#define tc_subr_2 6
	#define tc_subr_3 7
	#define tc_lsubr  8
	#define tc_fsubr  9
	#define tc_msubr  10
	#define tc_closure 11

	tc_subr_0..3 is a regular function of 0..3 arguments.
	tc_lsubrs are... gc-status
	tc_fsubrs are... define lambda set! quote the-environment
	tc_msubrs are... if begin and or let-internal
	tc_closures are created at runtime.

    I'm certain I don't see the difference yet.

Section 5.2, para 3.

    "Variable definitions appearing within the body of such an
    expression, or within the bodies of a library or top-level
    program, are treated as a set of letrec* bindings"

    "such an expression" refers to expressions that declare local
    variables, e.g., lambda, let, and friends.  So a variable
    created by a definition is just another local variable.
    And a definition can appear anywhere.

Symbol Table Layout.

    Top level and each library have their own environment.  (Q.  Does
    a library's env start empty?  Can't be quite empty...)  Binding
    expressions push a scope onto the current environment.  Definitions
    create an entry in the current scope.

    The absolute simplest implementation would have the env as a list
    of scopes, and each scope is a list of (name . value) pairs.

    def lookup(name):
	for scope in env:
	    for var, value in scope:
	       if var == name:
		    return value

    But...  name is a symbol.  Each symbol is a unique object.  Can
    we turn it inside out where we start from the symbol and find the
    current binding?  In constant time, even?  Need to be
    thread-safe...

    In SIOD, define takes an optional env.  If env is null, then
    define just writes the symbol's value cell.  If env is non-null,
    then define does this.

        (set! env (cons (cons var (car env)) (cons val (cdr env))))

    So env has two parallel lists.  A list of vars (symbols) and
    a list of values.  At environment exit time, those would just
    be peeled back.

    That's cool.  Symbol lookup is constant time.  Symbol definition
    is constant time.  Scope entry is constant time.  Scope exit
    is O(number of name conflicts), which is normally small.

    The env is part of the reader's state, so the reader has
    to have per-thread (probably automatic) state.

Section 5.10 says that some storage is immutable.  Figure out how to do that...

----------------------------------
9/24/2008

Extensions
define new in-memory object formats.
define new scheme data types.
define new scheme functions.
define new scheme syntax.

A scheme function has:
   a namespace (library),
   a name,
   an arg list,
   code.

A scheme syntax has:
   a namespace (library),
   a name,
   an arg list,
   code.

A namespace is a Scheme <library name> form, as a C string.
E.g., "(rnrs base (6))".

Imagine two include files:
   scheme-extension.h - used to extend the Scheme core
   scheme.h - used to embed Scheme.

So,something like this.
#include "extend.h"

DEFINE_PROC("boolean?", (x))
{
   return make_boolean(is_boolean(x));
}

DEFINE_SYNTAX("set!", (name value))
{
    
}

DEFINE_LIBRARY_PROC("foo", (mylib sublib (1 2 3)))
{
    return make_boolean(false);
}

----------------------------------
9/28/2008

primitives have the following macros.
    ARGLIST
    ENV
primitives have the following control-flow macros.
    RETURN(value);
    YIELD(value);    /* only used for multi-value functions */
    RAISE(condition);
    RAISE_CONTINUABLE(condition);
The last three leave all local variables in an undefined state.
(Where's a good place to save them?)
    EVAL(object);
    SAVE(variable);  /* var must be type (obj_t *) */
    RESTORE(variable);

Implement the stack as a list?

----------------------------------
9/28/2008

labels in SICP section 5.4:
     eval-dispatch
     ev-self-eval
     ev-variable
     ev-quoted
     ev-lambda
     ev-application
*    ev-appl-did-operator
     ev-appl-operand-loop
*    ev-appl-accumulate-arg
     ev-appl-last-arg
*    ev-appl-accum-last-arg
     apply-dispatch
     primitive-apply
     compound-apply
     ev-begin
     ev-sequence
*    ev-sequence-continue
     ev-sequence-last-expr
     ev-if
*    ev-if-decide
     ev-if-alternative
     ev-if-consequent
     ev-assignment
*    ev-assignment-1
     ev-definition
*    ev-definition-1
     read-eval-print-loop
*    print-result
     unknown-expression-type
     unknown-procedure-type
     signal-error

* used as return address.

----------------------------------

eval calls
    eval_list

eval_list calls
    eval_list
    eval_arglist
    eval_procedure

eval_arglist calls
    eval_arglist
    eval

eval_procedure calls
    primitives
    eval_apply

eval_apply calls
    eval_multi

eval_multi calls
    eval

primitives call
    eval

----------------------------------
10/01/2008

eval simple object:
    build one frame: { cont=0, exp,env=..., val=0 }
    call b_eval.
    b_eval sets val=..., calls RETURN.

eval nilary procedure:
    build one frame: { cont=0, exp,env=..., val=0 }
    call b_eval.
    b_eval pushes 2nd frame: { cont=b_have_operator, exp=... } -> { cont=0, exp,env=..., val=0}
    call b_eval. <====???
    b_eval sets val=#<proc '='>, calls RETURN.
    call b_have_operator.


----------------------------------
10/17/2008

Read barriers.

I think each obj_* operation can verify its subject on entry with
something like this.

	ENSURE_TOSPACE(obj);

#define ENSURE_TOSPACE(x) (!is_null((x)) && ((x) < to_space || (x) >= to_space_end) ? (x) = move_obj(x) : (x))

Or, as a function,

    obj_t *ensure_tospace(obj_t *obj)
    {
	if (is_null(obj))
	    return obj;
	if (to_space <= obj && obj < to_space_end)
	    return obj;
	return move_obj(obj);
    }
    #define ENSURE_TOSPACE(x) ((x) = ensure_tospace(x))

Anyway, everytime an obj's public method dereferences a pointer field,
it also does the ensure_tospace thing.

    obj_t *some_obj_get_thingie(obj_t *obj)
    {
	ENSURE_TOSPACE(obj);
        some_obj_t *so = (some_obj_t *)obj;
        return ensure_tospace(so->so_thingie);
    }

----------------------------------
The alternative is to keep auto storage locations on a linked list
or stack, and traverse that list when flipping.

    struct obj_ref {
        obj_t **ref;
	obj_ref *next;
    };

    __thread obj_ref *auto_head;

    #define OBJ(x) obj_t *x; obj_ref r = { &x, auto_head }; auto_head = r;
       
and make it illegal to DECLARE an obj in a loop.

    my_proc()
    {
	OBJ(o);
	for (o = some_list; o; o = pair_cdr(o))
	    ...;
    }

But how do we find implicit pops?  Compare stack pointer?
Zap the list each time through the threaded eval loop?

----------------------------------
That doesn't quite cut it.  Instead, let's have a new arg that gets
passed to every function.  Call it HEAP or ROOT or ALLOC or something.

Each function or block entry has code to initialize HEAP:

    my_proc(HEAP__, ...)                     | This much comes
    {                                        | from the DEFINE_PROC
        some_struct HEAP = { HEAP__, ... };  | macro.
	...
	return make_pair(HEAP, some_car, some_cdr);
    }

    #define THIS_FUNCTION_USES_THE_HEAP some_struct HEAP = { HEAP__, ... }

Then roots are defined from HEAP.

        HEAP_ROOT(obj); obj = make_symbol(L"foo");

    #define HEAP_ROOT(obj) obj_t *obj = NIL;  heap_record_obj(HEAP, obj);

----------------------------------
Third alternative.  May be independent of the first two.

Make FRAME a thread-global variable.
Then blocks just return a value.
Each thread's FRAME is a root.

----------------------------------
11/28/2008

I'm up against the problem that a lot of primitives need to be
implemented.  Some of them seem to be best implemented as macros.
E.g., let in terms of lambda and letrec (from r6rs Appendix B).

    (define-syntax let
      (syntax-rules ()
        ((let ((name val) ...) body1 body2 ...)
         ((lambda (name ...) body1 body2 ...)
          val ...))
        ((let tag ((name val) ...) body1 body2 ...)
         ((letrec ((tag (lambda (name ...)
                          body1 body2 ...)))
            tag)
          val ...))))

Note that only "named let" uses letrec, so you can define let in terms
of letrec and letrec in terms of let.

From the Scheme FAQ:

    (define-syntax letrec
	(syntax-rules ()
	  ((_ ((var init) ...) . body)
           (let ()
             (define var init)
	     ...
	     (let () . body)

But many primitives can be implemented as simple procedures.  They
don't need macros.

Trivial example: list.

	(define (list . args) args)

So I'm thinking I should start on a system of loading libraries from
source files at startup.  That means defining a search path and a way
to control loading.  Or maybe the C code should just have a read-file
primitive and a mechanism for reading a file into a namespace.  Then
I could implement the import mechanism in Scheme.

----------------------------------
12/2/2008

Finishing the reader.

Things the scanner can return:
       begin-datum-comment: #;
       identifier (symbol)
       booleans: #t, #f       
       character
       string	
       number (fixnum w/ sign)
       ( ) [ ] .
       begin-vector: #(
       begin-bytevector: #vu8(
       quote: '
       quasiquote: `
       unquote: ,	   
       unquote-splicing: ,@
       syntax: #'
       quasisyntax: #`
       unsyntax: #,
       unsyntax-splicing: #,@

Things not to implement yet: many character formats,
non-decimal-fixnum numbers, vectors, bytevectors.

Grammar:

    program ::= datum*

    datum ::= lexeme | compound

    lexeme ::= boolean | character | string | number

    compound ::= ( datum* ) | [ datum* ] | abbrev datum
		 (or vector or bytevector)

How to handle comment?
    comment ::= ... | #; interlexeme-space datum

Have a datum-sequence nonterminal which is made of data and
datum-comments.  The actions discard the commented data.  Or have a
parallel set of productions for commented data which don't build
anything.  (I like the latter...)
